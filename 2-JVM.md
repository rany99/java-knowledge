# JVM

[TOC]

## 1 概述

### 1.1 JVM

**JVM** 是 Java Vitural Machine（Java 虚拟机）的缩写，JVM 是一种用于计算设备的规范，是一个虚构出来的计算机，是通过在实际上的计算机仿真模拟各种计算机功能来实现的。

JVM 使得 Java 语言可以在不同平台上运行时不需要重新编译。 Java 语言使得 Java 虚拟机屏蔽了与平台相关的信息，使得 Java 语言编译程序只需要生在在 Java 上运行的目标代码（字节码/Class文件），就可以在多种平台上不加修改的运行。

### 1.2 JDK

**JDK**：Java Development Kit， Java 开发环境，是程序员使用 Java 语言编写 Java 程序所需的开发工具包，是提供给程序员使用的。 JDK 包含了 JRE， 同时还包含了编译 Java 源码的编译器 javac， 还包含了很多 Java 程序调试和分析的工具： jconsole， jvisualvm 等工具软件，还包含了 java 程序编写所需的文档和 demo 例子程序。

### 1.3 JRE

**JRE**： JAva Runtime Environment， Java 运行时环境，包含了 Java 虚拟机， Java 基础类库。是使用 Java 语言编写的程序运行所需的软件环境，是提供给想运行 Java 程序的用户使用的。

## 2 Java 内存区域

### 2.1 概述

Java 内存区域（JVM运行时数据区域）实在操作系统的堆中，一个 Java 应用会有一个对应的 JVM。

### 2.2 运行时的数据区

<img src="C:\Users\a3781\AppData\Roaming\Typora\typora-user-images\image-20230418141511858.png" alt="image-20230418141511858" style="zoom: 33%;" />

#### 2.2.1 程序计数器

记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空） ，即**记录程序执行到第几行了**。

#### 2.2.2 Java虚拟机栈

每个 Java 方法在执行的同时会创建一个**栈帧**用于**存储 Java 方法的局部变量表（基本类型 + 引用符号）、操作树栈、常量池引用、方法出口等信息**。从方法调用直到执行完成的过程，对应着一个栈帧在虚拟机栈中入栈和出栈的过程。

<img src="C:\Users\a3781\AppData\Roaming\Typora\typora-user-images\image-20230418142410597.png" alt="image-20230418142410597" style="zoom: 33%;" />

可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为256K，在 JKD 1.5+ 中默认为 1M：

```
java -Xss2M HackTheJava
```

该区域可能抛出以下异常：

- 当线程请求的栈深度超过最大值，会抛出 `StackOverflowError` 异常；
- 栈进行动态扩展时如果无法申请到足够内存，会抛出 `OutOfMemoryError` 异常。

#### 2.2.3 本地方法栈

**本地方法栈与 Java 虚拟机栈类似**，他们之间的区别在于本地方法栈为本地方法服务。

**本地方法**：本地方法一般是用其他语言（C、C++ 或 汇编语言）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。

<img src="C:\Users\a3781\AppData\Roaming\Typora\typora-user-images\image-20230418143105862.png" alt="image-20230418143105862" style="zoom:33%;" />

#### 2.2.4 堆（共享）

**主要存储已经生成的对象**（数组也被视为一种对象），是垃圾收集的主要区域（"GC堆"）。

现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象次啊去不同的垃圾回收算法。可以将对分成两块：

- **新生代（Young Generation）**：还可以继续细分为Eden区、Survivor0区、Survivor1区。新创建的对象一般储存在E区（大对象直接进入老年代，因为需要大片连续空间），E区中的对象熬过一次GC后年龄加一进入S区。
- **老年代（Old Generation）：**熬过一定次数（一般为15）的GC的对象或者大对象一般存储在这里。

**堆空间不需要是一片连续的内存空间，因此可以动态的增加其内存，增加失败时会抛出 `OutOfMemoryError` 异常。**

可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置为初始值，第二个参数设置为最大值。

```
java -Xms1M -Xmx2M HackTheJava
```

#### 2.2.5 方法区（共享）

**用于存放已经被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。**

**与堆一样，方法区也不需要时一片连续的内存空间，因此可以动态的增加其内存，增加失败时会抛出 `OutOfMemoryError` 异常。**

对方法区进行垃圾回收的主要目标是对常量池的回收和堆类的卸载，但是一般比较难以实现。

**在 JDK 1.8 之后，方法区被取消，直接移入内存中。**

<img src="C:\Users\a3781\AppData\Roaming\Typora\typora-user-images\image-20230418150600131.png" alt="image-20230418150600131" style="zoom: 67%;" />

**元空间和永久代都是方法区的一种实现**。在 Java 官方的 HotSpot 虚拟机中， Java 8 版本以后，使用元空间来实现的方法区；在 Java 8 之前的版本，则是使用永久代（与堆时连续的内存）实现方法去；在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。类的辕信息存储到原空间中，静态变量和常量池等放入堆中。

##### **为什么改用元空间实现方法区**

- **减少OOM（OutOfMemory）**：整个永久代有一个 JVM 本身设置固定大小上线（受 MaxPermSize 控制），很难调整到一个合适的值，大小很容易OOM；而元空间则是直接使用内存，受本机可用内存限制，虽然还是会出现溢出造成OOM，但是相较于使用永久代出现OOM的概率要小得多。
- **加载更多的类**：元空间中存放的是类的元数据，加载类的数量上限是由系统的实际可用空间来控制，这样加载的类就更多了（Java 程序功能复杂，用到的类和动态生成的类越来越多了）。
- JDK 1.8 合并了 HotSpot 和 JRockit 的代码，JRockit 没有永久代，合并之后就没有再重新设置永久代。

**再 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。类的元信息放入元空间存储，静态变量和常量池放入堆中**。

#### 2.2.6 运行时常量池（共享）

运行时常量池是方法区的一部分。

Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后放入这个区域。

除了再编译器生成的常量，还允许动态生成，例如String类的intern()。

#### 2.2.7 直接内存（共享）

再 JDK 1.4 中引入了 NIO 类，可以使用 Native 函数库直接分配堆外内存，然后通过Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些乘警中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。

### 2.3 HotSpot虚拟机

#### 2.3.1 对象创建过程

对于 new 指令，会按照以下五个步骤进行对象创建：

1. **检查常量池中，是否有待创建对象所属类的符号引用**
   - 若常量池中没有此类的符号引用，说明类还没有被定义，抛出 `ClassNotFoundException`；
   - 若常量池中有此类符号引用，继续下一步。
2. **检查该符号引用所代表的类，是否已经被 JVM 加载**
   - 该类尚未被加载→找到该类的 class 文件，并加载进方法区
   - 该类已经被加载→准备为对象分配内存
3. **根据方法区中该类的信息，确定该类所需的内存大小**
   - 一个对象所需的内存大小，在该对象所属的类被被定义完就能确定的，并且一个类所产生的所有对象的内存大小一样。
   - JVM 在一个类被加载进方法区时，就知道该类的每个对象所需内存大小。
   - 从堆中划分出一块对应大小的内存空间给新的对象，分配堆中的内存有两种方式：**指针碰撞（Bump the Pointer）**和**空闲列表（Free List）**。
4. **设置对象头**
5. **调用对象的构造函数进行初始化**

**JVM 在分配对象时具体采用哪种内存分配方法，取决于使用了哪种GC算法。**

##### 指针碰撞（Bump the Pointer）

若GC采用**复制算法**或者**标记-整理算法**，则堆中空闲内存是完整的区域，并且空闲内存和已使用内存之间有一个指针标记。那么当为一个对象分配内存时，只需要移动指针即可。

因此在这种完整的空闲区域上通过移动指针来分配内存的方式就叫做“指针碰撞”。

##### 空闲列表（Free List）

如果GC采用**标记-清除算法**，则堆中空闲区域和已用区域交错，因此需要使用一张“空闲列表”来记录堆中哪些区域是空闲区域，进而在创建对象时，根据这张“空闲列表”找到空闲取悦，并分配内存。

#### 2.3.2 对象的存储结构/内存布局

对象由**成员变量**和**成员函数**两部分组成。

对象在内存中的存储布局由**对象头（Object Header）**、**实例数据（Instance Data）**及**对齐补充（Padding）**三部分组成。

##### **2.3.2.1 对象头（Object Header）**

**存储对象在运行过程中自身所需的一些数据**

如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。**是实现锁机制的关键**。

**类型指针，对象指向它的类元数据的指针**

JVM 通过该指针来确定该对象是哪个类的实例。如果对象是个数组，那么对象头中还需要包含数组长度（因为从数组的元数据无法确定数组的大小）

##### **2.3.2.2 实例数据（Instance Data）**

程序定义的各种字段的内容，包含父类和子类内容都会被记录下来。

存储真实的对象数据，包含了对象中的所有字段属性信息，它们可能是某个其他对象的地址引用，也可能是基础数据的数据值。

##### **2.3.2.3 对齐补充（Padding）**

并非必然存在，无特别含义，仅仅只是占位符的作用。

**为什么要有对齐补充**

HotSpot 要求所有对象的大小必须是 8 字节的整数倍。由于对象的起始地址必须是 8 字节整数倍，但是实例数据部分的长度是任意的，所以需要对齐补充来充当占位符补充到八字节。

#### 2.3.3 对象的访问和定位

##### 2.3.3.1 对象访问的过程

栈上的 reference 数据存放的是一个地址，根据地址类型的不同，对象有不同访问方式：

**句柄访问方式**

Java 堆中有块“句柄池”内存，用于存放所有对象的地址和所有对象所属类的类信息；

reference 中存放的是对象在句柄池中的地址。访问对象时，先通过 reference 找到该对象的句柄，然后根据句柄中对象的地址再访问对象。、

**直接指针访问方式**

reference 直接存放对象地址，从而不需要句柄池，通过引用能够直接访问对象。但是对象所在内存空间中需要额外的策略存储对象所属的类信息的地址。

![img](https://s2.51cto.com/images/blog/202203/03025542_621fbdae3d36148362.png?x-oss-process=image/watermark,size_14,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp)

**句柄访问方式和直接指针访问方式的异同**

使用句柄访问方式的最大好处是 reference 中存储的是稳定的句柄地址，再对象被移动时也只改变句柄中的实例数据指针，而 reference 本身无需修改。

HotSpot 采用直接指针访问方式，因此只需要依次指针定位的时间开销，相对于句柄访问访问方式的两次须知操作，性能上快乐一倍。

## 3 垃圾回收和内存分配策略

### 3.1 概述

程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在与线程的生命周期内，每一个栈帧需要分配多少内存基本上在类结构确定时便已经确定，线程执行结束之后就会消失/被自动回收，者三个区域的内存分配和回收方式具有确定性。

垃圾回收和内存分配策略主要针对堆和方法区。因为一个方法锁执行的不同分支和条件所需要的内存可能不一样，需要在运行时才可以确定，因此这两个区域的内存分配和回收是动态的。

### 3.2 如何确定对象是否需要被回收/是否是垃圾

#### 3.2.1 引用计数法

**存在循环引用缺陷，Java 未使用。**

给对象中添加一个引用计数器，每当一个地方引用它时，计数器值加1，当引用失效时，计数器值减1，任何时刻计数器为0的对象是不可能再被使用的。

**优点**：实现简单，效率较高

**缺点**：

- 需要单独的字段存储计数器，这样的作法增加了存储空间的开销；
- 每次赋值都需要更新计数器，需要进行加减运算，增加了时间开销；
- 很难解决对象之间相互循环引用的问题，因此不被主流 Java 虚拟机使用。

#### 3.2.2 可达性分析算法

以一系列称为 `GC Root` 的对象作为起始点集，从这些节点开始根据应用关系向下搜索，搜索过的路径被称为应用链，如果对象没有和任何应用链关联，则认为它不可达及该对象不再被使用。

![image-20230418204518187](C:\Users\a3781\AppData\Roaming\Typora\typora-user-images\image-20230418204518187.png)

**GC Root 的构成**

- 虚拟机栈（栈帧中的本地变量表）中引用的对象（方法参数、局部变量等）
- 本地方法栈（Native 方法）中引用的对象
- 方法区中静态属性引用的对象
- 方法去中常量引用的对象（如字符串常量池中的引用）

