# 设计模式

[TOC]

## 一 设计模式分类

![img](https://img-blog.csdnimg.cn/20200411190730722.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEyMjA5MA==,size_16,color_FFFFFF,t_70)

### 1 创建型设计模式

创建型设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符来直接实例化对象。这使得程序在判断某个给定实例需要创建那些对象时更加灵活。

- 单例(Singleton)：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
- 简单工厂(Simple Factory)：利用工厂生产不同的对象。
- 工厂方法(Factory Method)：用不同的工厂生产不同的对象，创建对象在子类中执行（是抽象工厂的特例）
- 抽象工厂(Abstract Factory)：使用不同的工厂生产不同的相关对象族
- 建造者(Builder)：简化复杂类的实例化/构建过程
- 原型(Prototype)：创建重复对象/克隆

###2 行为型模式

行为型设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。

- 策略(Strategy)：封装可以互换的行为，并由委托来决定具体使用哪一个
- 观察者(Observer)：当一个对象状态改变时，她的所有依赖都会收到通知并自动更新状态。
- 命令(Command)：将一个请求封装程一个对象，从而使您可以使用不同的请求来参数化其他对象。
- 模板(Template)：定义个算法骨架（步骤），将股价一部分具体步骤推迟到子类中进行实现。可以保证在不改变算法结构的同时，重新定义某些步骤。
- 迭代器(Iterator)：提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。
- 状态(State)：允许对象在内部状态改变时改变他的行为，对象看起来好像修改了它所属的类。

###3 结构型模式

- 适配器模式(Adapter)：作为两个不兼容接口之间的桥梁
- 外观模式(Facade)：将复杂的系统调用统一程一个对外的调用接口
- 桥接模式(Bridge)：用于把抽象话与是鲜花解耦，使二者可以独立变化
- 装饰器模式(Decorator)：允许向一个现有对象添加新的功能，同时又不改变其原始结构
- 组合模式(Composite)：将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象
- 代理模式(Proxy)：为其他对象提供一种代理以控制整个对象的访问

## 二 设计模式的六大原则(SOLID)

### 1 单一责任原则（Single Responsibility Principle）

一个类只负责做一件事。（高内聚、低耦合）

### 2 开闭原则（open closed principle）

类应该对扩展开放，对修改关闭

- 花费大量时间编写并完成测试后的代码不应该被随意修改
- 使用各类设计模式可以在不改变原始类的情况下很容易地扩展类的行为（热插拔）

实现上述效果，必须充分利用接口和抽象类

###3 里氏替换原则（LSP liskov substitution principle）

子类可以扩展父类的功能，但不能改变原有父类的功能（本质就是多态），以增强程序的健壮性。实际项目中，每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑。

###4 最少知识原则（law of demeter LOD）

最少只是原则告诉我们应该尽量减少对象之间的交互，避免让太多的类耦合在一块，如果太多的类耦合在一起，系统将变得复杂而不易被其他人了解，增加维护难度。

### 5 接口隔离（interface segregation principle）

建立单一接口，即：

- 客户端不应该依赖它不需要的接口
- 类之间依赖关系应该建立在最小的接口上

### 6 依赖倒置原则（dependence inversion principle）

要依赖抽象，不要依赖具体类。编程要针对接口而不是具体的实现类。“倒置”体现在底层具体实现类依赖于高层需要的接口抽象。

- 变量不可以持有具体类的引用（如使用`new`创建对象）。
- 不要让类派生自具体类，而应该派生自抽象类或者接口。
- 不要覆盖基类中已经实现的方法（否则需要重新考虑在基类中将该方法设计成抽象方法或者移除该方法，因为基类中的方法实现应该由所有子类共享）。

优点：

- 各个模块之间松耦合，相对独立，易于维护
- 使用者不需要知道所有细节，易于开发和维护

缺点：

- 会增加很多用于处理组件之间沟通的包装类，增加开发时间，可能降低软件性能

## 三 具体设计模式

### 1 单例模式

**概述**

确保一个类只有一个实例，并提供该实例的全局访问点。可以节约系统资源，避免对对象频繁销毁和创建。如线程池，缓存，日志都只需要一个实例。

**类图**

使用一个**私有构造函数**，一个**私有静态变量**以及一个**公有静态函数**来实现。

私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。

![image-20230412202922260](C:\Users\a3781\AppData\Roaming\Typora\typora-user-images\image-20230412202922260.png)

**应用**

- 网站的计数器，采用单利模式实现，否则难以同步；
- 应用程序的日志应用，只有一个实例去操作才好，否则内容不好追加显示；
- 多线程的线程池的设计一般也是采用单利模式，因为线程池要方便对持中的线程进行控制；
- Windows的任务管理器和回收站；

**优点**

- 在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是同一个实例。这样便可以防止其他对象对自己的实例化，确保所有对象都访问一个实例；
- 单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性；
- 提供了对唯一实例的受控访问；
- 由于在系统内只存在一个对象，因此可以节约系统资源，当需要频繁的销毁和创建对象时单例模式无疑可以提高系统的性能；
- 允许改变树木的实例；
- 避免了对共享资源的多重占用。

**缺点**

- 不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态；
- 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难；
- 单例类的职责过重，在一定程度上违背了“单一职责原则”。
- 滥用单例可能带来一定的负面问题，例如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连鸡翅对象的程序过多而痴线连接池移除；如果实例化的西乡长时间不被利用，系统会认为是垃圾而回首，进而导致重要单例对象的丢失。

**注意事项**

- 使用时不能用反射模式创建单例，否则会实例化一个新的对象；
- 使用懒单例模式时注意线程安全问题；
- 饿单例模式和懒单例模式的构造方法均是私有的，因此是不能被继承的。
- 单例模式防止反射漏洞攻击

```java
private static boolean flag = false;

private Singleton() {

	if (flag == false) {
		flag = !flag;
	} else {
		throw new RuntimeException("单例模式被侵犯！");
	}
}

public static void main(String[] args) {

}

```

**实现**

**饿汉模式**：类初始化时，会立即加载该对象，线程天生安全，调用效率高。

```java
package com.lijie;

//饿汉式
public class Demo1 {

    // 类初始化时,会立即加载该对象，线程安全,调用效率高
    private static Demo1 demo1 = new Demo1();

    private Demo1() {
        System.out.println("私有Demo1构造参数初始化");
    }

    public static Demo1 getInstance() {
        return demo1;
    }

    public static void main(String[] args) {
        Demo1 s1 = Demo1.getInstance();
        Demo1 s2 = Demo1.getInstance();
        System.out.println(s1 == s2);
    }
}
```

**懒汉模式**：类初始化时不会初始化该对象，在真正需要使用的时候才回创建该对象，具备懒加载功能。

```java
package com.lijie;

//懒汉式
public class Demo2 {

    //类初始化时，不会初始化该对象，真正需要使用的时候才会创建该对象。
    private static Demo2 demo2;

    private Demo2() {
        System.out.println("私有Demo2构造参数初始化");
    }

    public synchronized static Demo2 getInstance() {
        if (demo2 == null) {
            demo2 = new Demo2();
        }
        return demo2;
    }

    public static void main(String[] args) {
        Demo2 s1 = Demo2.getInstance();
        Demo2 s2 = Demo2.getInstance();
        System.out.println(s1 == s2);
    }
}
```

**静态内部类：**静态内部类结合了懒汉式和饿汉式各自的有点，真正需要对象的时候才回加载，加载类是线程安全的。

```java
package com.lijie;

// 静态内部类方式
public class Demo3 {

    private Demo3() {
        System.out.println("私有Demo3构造参数初始化");
    }

    public static class SingletonClassInstance {
        private static final Demo3 DEMO_3 = new Demo3();
    }

    // 方法没有同步
    public static Demo3 getInstance() {
        return SingletonClassInstance.DEMO_3;
    }

    public static void main(String[] args) {
        Demo3 s1 = Demo3.getInstance();
        Demo3 s2 = Demo3.getInstance();
        System.out.println(s1 == s2);
    }
}
```

**枚举单例式**：使用枚举实现单例模式。枚举本身就是单例，实现简单，调用效率高，在JVM层面上提供保证，避免了反射和反序列化的楼栋，缺点是没有延迟加载。

```java
package com.lijie;

//使用枚举实现单例模式 优点:实现简单、枚举本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞 缺点没有延迟加载
public class Demo4 {

    public static Demo4 getInstance() {
        return Demo.INSTANCE.getInstance();
    }

    public static void main(String[] args) {
        Demo4 s1 = Demo4.getInstance();
        Demo4 s2 = Demo4.getInstance();
        System.out.println(s1 == s2);
    }

    //定义枚举
	private static enum Demo {
		INSTANCE;
		// 枚举元素为单例
		private Demo4 demo4;

		private Demo() {
			System.out.println("枚举Demo私有构造参数");
			demo4 = new Demo4();
		}

		public Demo4 getInstance() {
			return demo4;
		}
	}
}
```

**双重检测锁方式**：因为JVM本质重排序的原因，可能会初始化多次，不建议使用

```java
package com.lijie;

//双重检测锁方式
public class Demo5 {

	private static Demo5 demo5;

	private Demo5() {
		System.out.println("私有Demo4构造参数初始化");
	}

	public static Demo5 getInstance() {
		if (demo5 == null) {
			synchronized (Demo5.class) {
				if (demo5 == null) {
					demo5 = new Demo5();
				}
			}
		}
		return demo5;
	}

	public static void main(String[] args) {
		Demo5 s1 = Demo5.getInstance();
		Demo5 s2 = Demo5.getInstance();
		System.out.println(s1 == s2);
	}
}
```

### 2 工厂模式

#### 工厂模式是什么

工厂模式提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象是不会对客户端暴露创建逻辑，而是通过使用一个共同的接口来指向新创建的对象，实现了创建者和调用者分离，工厂模式分为简单工厂、工厂方法、抽象工厂模式。

#### 工厂模式的好处

- 工厂模式是我们最常用的实例化对象模式，是用工厂方法替代new操作的一种模式；
- 利用工厂模式可以降低程序的耦合性，为后期维护修改提供了很大的便利；
- 将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。

#### Spring中的工厂设计模式

**Spring IOC**

- 在Spring IOC容器创建bean的过程是使用了工厂设计模式；
- Spring中无论是通过xml配置还是通过配置类还是注解进行创建bean，大部分都是通过简单工厂来进行创建的；
- 当容器拿到了beanName和class类型后，动态的通过反射创建具体的某个对象，最后将创建的对象放到Map中。

**为什么Spring IOC要采用工厂模式创建Bean**

- 在实际开发中，对象之间的A→B，B→C调用会使程序的耦合性非常高，即类与类之间依赖，方法与方法之间依赖。
- 直接使用new来获取对象，会使得耦合性大大提升，代码重复量高。
- 为避免这种情况，Spring采用工厂模式编程，写一个工厂，由工厂创建Bean，如果需要对象直接向工厂请求即可。
- Spring IOC容器的工厂中有个静态的Map集合，是为了让工厂符合单例设计模式，即每个对象只生产一次，生产队向后就存到Map集合中，保证了实例不会重复影响程序效率。

#### 工厂模式分类

- 简单工厂模式：用来生产同一等级结构中的任意产品。（不支持拓展增加产品）
- 工厂方法模式 ：用来生产同一等级结构中的固定产品。（支持拓展增加产品）
- 抽象工厂 模式：用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族）

#### 2.1 简单工厂模式

**概述**

在创建一个对象时不想客户暴露内部细节，并提供一个创建对象的通用接口。这可以实现在产生对象时进行权限控制、修饰、日志记录等操作，对于直接new一个对象来说，这是不容易做到的。

单例模式实际上也算是一种工厂模式（静态工厂getInstance）。

**优点**

简单工厂模式能够根据外界给定的信息，决定究竟该创建哪个具体类的对象。明确区分了各自的职责和权利，有利于整个软件体系结构的优化。

**缺点**

- 工厂一旦需要产生新的产品就需要修改工厂类的方法逻辑，违背了开放-关闭原则。
- 工厂类集中了所有实例的创建逻辑，容易违反GRASPR的高内聚的责任分配原则。

**类图**

简单工厂把实例化的操作单独放到一个类中，这个类就成了简单工厂类，让简单工厂类来决定该用哪个具体子类来实例化。

这样做的好处是可以把客户类和具体子类实现解耦，客户类不在需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都需要知道所有的子类的细节，一旦子类发生改变，例如增加子类，那么所有的客户类都要进行相应的修改。

![image-20230412220308992](C:\Users\a3781\AppData\Roaming\Typora\typora-user-images\image-20230412220308992.png)

**实现**

创建工厂

```java
package com.lijie;

public interface Car {
	public void run();
}
```

创建工厂内的产品

```java
package com.lijie;

//产品1 宝马
public class Bmw implements Car {
	public void run() {
		System.out.println("我是宝马汽车...");
	}
}

//产品2 奥迪
public class AoDi implements Car {
	public void run() {
		System.out.println("我是奥迪汽车..");
	}
}
```

创建核心工厂类，由核心工厂类决定调用那种产品的生产方法

```java
package com.lijie;

public class CarFactory {

	 public static Car createCar(String name) {
		if ("".equals(name)) {
             return null;
		}
		if(name.equals("奥迪")){
			return new AoDi();
		}
		if(name.equals("宝马")){
			return new Bmw();
		}
		return null;
	}
}
```

具体实例

```java
package com.lijie;

public class Client01 {

	public static void main(String[] args) {
		Car aodi  =CarFactory.createCar("奥迪");
		Car bmw  =CarFactory.createCar("宝马");
		aodi.run();
		bmw.run();
	}
}
```

#### 2.2 工厂方法模式

**概述**

又称多态性工厂模式，通过工厂父类定义创建对象的公共接口，而子类负责生成具体的对象。将类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，即由子类来决定应该实例化（创建）哪一个类。

> 工厂方法模式把具体产品的创建推迟到工厂类的子类（具体工厂）中，此时工厂类不再负责所有产品的创建，而只是给出具体工厂必须实现的接口，这样工厂方法模式在添加新产品的时候就不修改工厂类逻辑而是添加新的工厂子类，符合`开放 - 封闭`原则，克服了简单工厂模式中缺点。

**类图**



**优点**



### 3 观察者模式

**概述**

定义对象之间的一种**一对多**的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

**类图**

![image-20230412195834140](C:\Users\a3781\AppData\Roaming\Typora\typora-user-images\image-20230412195834140.png)

- **Subject： **主题，定义了注册和移除观察者、并通知所有观察者（类似PUSH的机制）的接口，主题的实现类可以通过维护一张观察者列表来实现这些操作。
- **ConcreteSubject：** Subject接口的具体实现类，内部需要维护一张观察者Observer的列表。
- **Observer：** 观察者，定义了需要被Subject调用的update()接口
- **ConcreteObserver：** 观察者接口的具体实现类，在构造时需要传入一个Subject指针，方便随时把自己**注册/取消注册**为观察者。

**应用**

- 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
- 一个对象必须通知其他对象，而不知道这些对象是谁。
- 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响对象C，C对象将......，可以使用观察者模式创建一种链式触发机制。

**优点**

- 观察者和被观察者是抽象耦合的（交互对象之间具有松耦合的特性）。
- 简历一套触发机制。

**缺点**

- 观察者种类繁多，需要的数据也可能不同意，此时主题需要针对每种不同的观察者使用不同的update()接口，代码又会产生耦合了。
- 如果观察者和观察目标间有循环依赖，可能导致系统崩溃。

**实现**

java 本身支持该模式，可使用`java.util.Observer`接口和`java.util.Observable`类。但是java支持单继承，所以这也就限制了`Observable`的使用。

